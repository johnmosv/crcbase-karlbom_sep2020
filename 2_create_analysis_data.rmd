---
title: "MR1: Make analyses data"
output: 
    html_document:
        highlight: pygments
        theme: sandstone
        css: style.css
        toc: true
        code_folding: hide
editor_options: 
  chunk_output_type: inline
---

__Datum__: `r lubridate::today()`

```{r setup, include=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
library(data.table)
library(dplyr)
library(stringr)
library(glue)
library(janitor)
library(here)
library(scales)
library(ggplot2)
library(lubridate)
library(rlang)
library(plotly)

source("crcbase/helpers.R")
source("crcbase/fix_scrcr_dubletter.R")
source("vars/definitions.R")
source("functions/read_write.R")
source("crcbase/process_scrcr.R")

knitr::opts_chunk$set(
    # root.dir = '~/R/project',
    warning = FALSE,
    message = FALSE,
    warning = FALSE,
    echo = TRUE,
    include = TRUE
)

if (!exists("params")) {
    params <- list(
        project_name = "karlbom_sep2020"
    )
}
```

## 1. DATA


```{r read project data, echo=FALSE, include=TRUE}

if (!dir.exists("K:/crcbase") & !exists("project_rdata")) {
    stop("Cannot find k:")
}

scrcr = read_from_project_original("uk_scrcr_20210609.sas7bdat")
cci = read_from_project_original("uk_cci_20210609.sas7bdat")
cdr = read_from_project_original("uk_cdr_20210609.sas7bdat")
ileus = read_from_project_original("uk_ileus_20211210.sas7bdat")
migrations = read_from_project_original("uk_migrations_20211210.sas7bdat")
relapses = read_from_project_original("uk_relapse_pr_20210609.sas7bdat")
surgeries = read_from_project_original("uk_surgeries_20210609.sas7bdat")

```



##### SCRCR
The Swedish Colorectal Cancer Register
Used to identify the exposed populatio. All other datasets only contains information on individuals found in this dataset.

```{r process scrcr}
scrcr = process_scrcr(scrcr)
```

##### crd_clean 
Only used for death date
```{r crc clean}
cdr_clean = cdr[,.(lopnr, diagdate_scrcr, deathdate)]
nrow(cdr)
qplot(cdr$deathdate)
```

##### surgeries 
all IPR rows with op codes (before) specified [alot of codes, J, L, P chapers]

```{r surgeries}
# in the sas program, an array of codes are looped over and if surgerycodes == the current code, 
# it is saved in column code and exported into `surgeries`
surgeries_clean = surgeries[,.(lopnr, diagdate_scrcr, indate, outdate, hospital, hdia, surgerycodes, code)]
nrow(surgeries_clean)
surgeries_clean %>% tabyl(code) %>% table_dt(caption="Codes found in 'surgeries'")
length(unique(surgeries$code))
```

Used to identify: 
```{r}

for (op_class in names(definitions$procedure_codes)) {
    codes = definitions$procedure_codes[[op_class]]
    # A bit of hacky solution for dynamic name data.table
    surgeries_clean$temp = surgeries_clean$code %in% codes
    nrows = sum(surgeries_clean$temp)
    setnames(surgeries_clean, "temp", op_class)
    print(glue("{op_class} : {pcollapse(codes)}"))
    print(glue("Identified {nrows} rows"))
}

#tabyl(surgeries_clean, sbo_operation_alt1, sbo_operation_alt2, stoma_closure)
```

##### relapse 
first occurrence of ("C784" "C785" "C786" "C787") in patreg (in/out) after diagdate_scrcr
```{r relapse_pr_clean}
# relapse
```

##### ileus
All IPR rows (before and after crc diagnosis) indication either: 

 - ileus ("K565" "K566" "K567") 
 - ab_pain (R10.0, R10.3, R10.4)
 - ab_hernia (K40.0, K40.3, K41.0, K41.3, K42.0, K43.0, K43.3, K43.6, K44.0, K45.0, K46.0)

```{r ileus_clean}
#select columns and create dias variable
ileus_clean = ileus %>% select(lopnr, diagdate_scrcr, indate, outdate, hdia, dia1:dia30)
ileus_clean = ileus_clean %>% 
    tidyr::unite(dias, hdia:dia30, sep=" ") %>% 
    mutate(dias = str_remove_all(dias, "(NA)+"))

for (icd_group in names(definitions$icd_codes)) {
    
    icds =  definitions$icd_codes
    icds_pattern = paste0(icds, sep="|")
    print(icds_pattern)
    ileus_clean$temp <- str_detect(ileus_clean$icds, icds_pattern)

    print(icd_group)
    print(sum(ileus_clean$temp))
    setnames(ileus_clean, "temp", icd_group)
}
 
```

##### CCI
Charlson co-morbidity index

##### migrations 
specified in varaibles. Needed for censoring?.
Contains all migrations (immigrations and emigrations) after diagdate_scrcr



### Exposure
Cancer surgery (inlcuded in the population)

### Other variables 
Create variables needed for analyses. Specificed in the study plan

#### index_date = `min(proceduredate)`
Using proceduredate (`a1_opdat`) as index date

```{r index_date}
scrcr[, index_date := min(proceduredate), by = "lopnr"]
```
 hand cluster aroun height 49-100 and weigh 180-190 have probably switched height and weight when data was entered.


## 3. STUDY POPULATION

Identified from the `scrcr` dataset. Only the first crc will be included. If multiple first tumours are registerer, 
the row with the highest pTNM stadium followed by the least missing (for all variables) will be included.

```{r scrcr duplicates}
scrcr_pop <- fix_scrcr_dubletter(scrcr)

# create populatioin dataset.
pop <- scrcr_pop[, .(
    lopnr,
    diagdate_scrcr,
    diagyear_scrcr,
    index_date,
    female,
    diagage,
    surgery_type,
    proceduredate,
    curative_proc,
    stage, 
    procedure_type, 
    a2_opdat
)]
```

#### Inclusion criteria   
1. Patienter med CRC-diagnos 2007-2016   

```{r diadate}
# Already handled
tabyl(pop, diagyear_scrcr)
```

2. Stage 1-3 (mstage_clin == 1)
```{r anastomoskirurgi}
# Already handled
tabyl(pop, stage)
```

3. Patienter över 18 år (diagage > 50)   
```{r age}
# Not handled in indata
qplot(scrcr$diagage) +
    geom_vline(
        xintercept = 18, linetype = "dashed", color = "red"
    )
```

```{r remove under 50, echo=FALSE}
sum(pop$diagage <= 18)
pop <- pop[diagage > 18]
```

4. Bowel resection (procedure_type == 3)
```{r}
tabyl(pop, procedure_type)
```

#### Exclusion criteria  

1. Missing för surgery_type eller diagage   
```{r remove missing surgery type or diagage}
# Already handled
sum(is.na(pop$surgery_type) | is.na(pop$diagage))
```

2. Patienter med permanent stomi lagd (a2_perm == 1)   

```{r permanent stomi}
tabyl(pop, a2_perm)
# Removin permanent stomi from the population
pop <- pop[a2_perm != 1]
```

3. Missing på operationsdatum (proceduredate (?) ==.)   

```{r missing proceduredate}
sum(is.na(pop$proceduredate))
# Removing missing operationsdatum
pop <- pop[!is.na(proceduredate)]
```

#### Population size
```{r population lopnr}
pop_lopnr <- unique(pop$lopnr)
length(pop_lopnr)
```


## 4. MEASUREMENTS AND VARIABLES

### Primary outcome

_al_ = Anastomotic leakeage within 30 days of surgery   
* 1 = YES	if a4_anakomp (=true) OR a4_reopana (=true)   
* 0 = NO	else

The 30 days are already included in the variable (`a4_anakomp`)	
```{r al}
# Create al
pop[, al := case_when(
    truethy(a4_anakomp) | truethy(a4_reopana) ~ 1,
    TRUE ~ 0
)]

tabyl(pop, a4_anakomp, al)
tabyl(pop, a4_reopana, al)
```


### Secondary outcomes

_al_re_ =	Anastomotic leakeage with reintervention within 30 days of surgery 
* 1 = YES	if a4_reopana (=true) 
* 0 = NO	else

```{r al_re}
# Create al_re
pop[, al_re := case_when(
    truethy(a4_reopana) ~ 1,
    TRUE ~ 0
)]
tabyl(pop, al_re, al)
```


_dead90_ = Dead within 90 days of surgery
* 1 = YES	if procedure_date <= deathdate <= procedure_date+90   
* 0 = NO	else   

```{r dead90}

pop <- left_merge(
    pop,
    cdr[lopnr %in% pop$lopnr, .(lopnr, deathdate)]
)

pop[, dead90 := case_when(
    truethy(as.numeric(deathdate - proceduredate) <= 90 & proceduredate <= deathdate) ~ 1,
    TRUE ~ 0
)]
tabyl(pop$dead90)
```


### Exposure covariates
_estrogen_		Estrogen exposure
* 1 = YES 	if …
* 0 = NO	else

#### 1. _Group 1_: Estrogen decrease (relevant enbart för kvinnor med bröstcancer)



Bröstcancer before `diagdate_scrcr` is a must for all in group1

```{r estrogen decrease}


# Grupp 1 dataset
lmed_clean[, .N, by = "atc"]
lmed_clean[, .N]
estrogen_decrease <- lmed_clean[, .(lopnr, edate, atc, drug_class)]
estrogen_decrease <- estrogen_decrease[drug_class %in% c("er_blockers", "aromatase_inhibitors")]

# Add breastcancer info
estrogen_decrease <- merge(estrogen_decrease, bc_clean, by = "lopnr", all = TRUE)

# Remove rows without breast cancer
n_without_breastcancer <- length(unique(estrogen_decrease[is.na(flag_bc) | flag_bc == 0]$lopnr))
n_with_ed_prescription <- length(unique(estrogen_decrease$lopnr))
print(glue("Removing {n_without_breastcancer} lopnr with aromatase inhibitor/er blockers prescriptions but which have not had breastcancer"))
estrogen_decrease <- estrogen_decrease[flag_bc == 1]

# Cannot find a2_opdat using proceduredate instead (for crc)
estrogen_decrease <- merge(estrogen_decrease,
    pop[, .(lopnr, index_date, proceduredate)],
    by = "lopnr", all.x = TRUE
)

# Remove without drug class and after procedure date
estrogen_decrease <- estrogen_decrease[!is.na(drug_class)]
estrogen_decrease <- estrogen_decrease[edate <= index_date] # index_date=proceduredate

n_estrogen_decrease <- length(unique(estrogen_decrease$lopnr))
print(glue("Identified {n_estrogen_decrease} lopnr with breastcancer and AI or ER blocker prescriptions before proceduredate"))

# All of the estrogen decreasing ATCs are present in the data.
tabyl(estrogen_decrease, atc)
```

Drug dispensation indicating group 1 (before index date with flag_bc)
```{r}
# lmed_clean contains prescriptions <2 years prios diagdate_scrcr but now has follow up until proceduredate
estrogen_decrease[
    drug_class %in% c("er_blockers", "aromatase_inhibitors"),
    .(
        n_dispensations = .N,
        n_unique_loprn = length(unique(lopnr))
    ),
    by = "drug_class"
] %>%
    adorn_totals()
```


```{r estrogen increase histogram dispensation time from bc diagnosis}
estrogen_decrease %>%
    mutate(months_edate_bc = time_length(edate - diagdate_bc, unit = "months")) %>%
    ggplot(aes(x = months_edate_bc)) +
    geom_histogram(binwidth = 10) +
    labs(title = "All AI and ER-blocker prescriptions following breast cancer diagnosis")
```

```{r estrogen increase histogram dispensation time from crc diagnosis}
estrogen_decrease %>%
    mutate(months_edate_crc = time_length(edate - diagdate_scrcr, unit = "months")) %>%
    ggplot(aes(x = months_edate_crc)) +
    geom_histogram(binwidth = 1) +
    labs(title = "All AI and ER-blocker prescriptions in relation to scrcr diagnosis")
```

+ Women with breast cancer and adjuvant endocrine therapy with tamoxifen or fulvestrant (ER blocker) or aromatase inhibitor 
(AI; blocks production of estrogen) after breast cancer diagnosis.


```{r gr1_a}
estrogen_decrease[
    ,
    estrogen_decrease_er_or_ai_after_bc := ifelse(edate > diagdate_bc, 1, 0)
]
tabyl(estrogen_decrease, estrogen_decrease_er_or_ai_after_bc)
print("Almost all meet this requirment")
```

+ Tamoxifen and fulvestrant (L02BA01, L02BA03) (ER) and at least two withdrawals from the pharmacy consecutively (EDATUM)) 
and at least one time should be during the period 6 months prior to operation for CRC (a2_opdat). 

```{r gr1_b}

estrogen_decrease[, consecutively := ifelse(
    lopnr == lag(lopnr, default = 999) &
        drug_class == lag(drug_class, default = "1"),
    TRUE, FALSE
)]

# Have already dispensation before proceduredate. This is the time before dispensation in absolute value
estrogen_decrease[
    ,
    months_dispensation_to_surgery := time_length(abs(edate - proceduredate), unit = "months")
]

# Create the definition for gr1
estrogen_decrease[
    ,
    estrogen_decrease_er_prior_crc_surgery := ifelse(
        drug_class == "er_blockers" &
            consecutively == TRUE &
            months_dispensation_to_surgery <= 6 &
            months_dispensation_to_surgery >= 0,
        1, 0
    )
]

tabyl(estrogen_decrease, estrogen_decrease_er_prior_crc_surgery)
```

+ Aromatase inhibitors (L02BG03, L02BG04 and L02BG06) and at least two withdrawals from the pharmacy consecutively (EDATUM))
 and at least one time should be during the period 6 months prior to operation for CRC (a2_opdat). 


```{r gr1 ai before crc surgery}
estrogen_decrease[
    ,
    estrogen_decrease_ai_prior_crc_surgery := ifelse(
        drug_class == "aromatase_inhibitors" &
            consecutively &
            months_dispensation_to_surgery <= 6 &
            months_dispensation_to_surgery >= 0,
        1, 0
    )
]

tabyl(estrogen_decrease, estrogen_decrease_ai_prior_crc_surgery)
```

Creating new variable: `gr1_estrogen_decrease`
```{r grupp1 estroge_decrease new variable}

# One row per id for gr 1, for each diagdate_bc
gr1_ed <- estrogen_decrease[, .(
    gr1_estrogen_decrease_er_or_ai_after_bc = any(estrogen_decrease_er_or_ai_after_bc == 1),
    gr1_estrogen_decrease_er_prior_crc_surgery = any(estrogen_decrease_er_prior_crc_surgery == 1),
    gr1_estrogen_decrease_ai_prior_crc_surgery = any(estrogen_decrease_ai_prior_crc_surgery == 1)
), by = c("lopnr", "index_date", "diagdate_scrcr", "diagdate_bc")]


# Create the new gr1_estrogen_decrease variable. If any of the bulletpoint for Gr1 defintion
gr1_ed[,
    gr1_estrogen_decrease := any(
        gr1_estrogen_decrease_er_or_ai_after_bc,
        gr1_estrogen_decrease_ai_prior_crc_surgery,
        gr1_estrogen_decrease_er_prior_crc_surgery
    ),
    by = c("lopnr", "index_date", "diagdate_scrcr", "diagdate_bc")
]

gr1_ed[, .(
    n_estrogen_decrease = sum(gr1_estrogen_decrease),
    n_ai = sum(gr1_estrogen_decrease_ai_prior_crc_surgery),
    n_er = sum(gr1_estrogen_decrease_er_prior_crc_surgery),
    n_er_or_ai_after_bc = sum(gr1_estrogen_decrease_er_or_ai_after_bc)
)] %>%
    table_dt(caption = "Estrogen decrease, n fulfilling the different criterion")

# One row per id
gr1_ed_id <- gr1_ed[, .(
    gr1_estrogen_decrease = any(gr1_estrogen_decrease)
),
by = c("lopnr", "index_date") # There are some that have had multiple BC. If any fullfil the gr1 def that is fine!
]

# Add gr1 defintion to pop
pop <- left_merge(
    pop,
    gr1_ed_id,
    id = c("lopnr", "index_date")
)
pop[is.na(gr1_estrogen_decrease), gr1_estrogen_decrease := FALSE]

tabyl(pop, gr1_estrogen_decrease)
```


```{r duplicated bc}
if (any(duplicated(gr1_ed$lopnr))) {
    print("Some have multiple breastcancer diagdate")
    dup_bc <- gr1_ed[duplicated_all(lopnr), .N, by = "lopnr"]
    dup_bc %>% tabyl(N)
}
```

##### Seperate ER blockers from AI  
All in gr2 estrogen decrease get a flag indicating whether the last dispensed drug was an ER blocker or AI
```{r er blocker or ai}

# add proceduredate
ed_type <- left_merge(
    lmed_clean,
    pop[, .(lopnr, proceduredate)],
    id_vars = "lopnr"
)

ed_type <- ed_type[lopnr %in% gr1_ed_id$lopnr &
    edate <= proceduredate &
    drug_class %in% c("er_blockers", "aromatase_inhibitors")]

setorder(ed_type, lopnr, -edate)
ed_type <- ed_type[!duplicated(lopnr)]
setnames(ed_type, "drug_class", "gr1_drug_class")

pop <- left_merge(pop, ed_type, id_vars = c("lopnr", "proceduredate"))

tabyl(pop, gr1_drug_class) %>%
    adorn_totals() %>%
    table_dt(caption = "Er blockers or AI for group estrogen decrease")
```
 
#### 2. _Group 2:_ Estrogen increase (relevant för samtliga) 



+ Postmenopausal women with HRT treatment (G03CA03, G03CA04, G03CC07, G03CX01, G03FA, G03FB) 
and at least two withdrawals from the pharmacy consecutively (EDATUM)) and at least one time 
should be during the period 6 months prior to operation for CRC (`a2_opdat`). 

```{r group2 estrogen increase}

gr2_ei_lmed <- lmed_clean # need all drug_classes for bullet point 2 [drug_class == "hrt_treatment"]
gr2_ei_lmed <- merge(
    gr2_ei_lmed,
    pop[, .(lopnr, diagdate_scrcr, index_date, proceduredate)],
    by = "lopnr", all.x = TRUE
)

# All prescriptions must occurr before proceduredate
gr2_2_ei_lmed <- gr2_ei_lmed[edate <= proceduredate]

gr2_ei_lmed[
    drug_class == "hrt_treatment",
    `:=`(
        # Negative numbers occurr before proceduredate
        months_hrt_crc_surgery = time_length(edate - proceduredate, unit = "months")
    )
]

# Aggregate per lopnr, needed for the bulletpoints
gr2_ei <- gr2_ei_lmed[, .(
    hrt_dispensations_crc_surgery_6months = any(months_hrt_crc_surgery < 0 & months_hrt_crc_surgery >= -6),
    n_hrt_dispensations_before_index = sum(drug_class == "hrt_treatment"),
    n_er_or_ai_dispensations_before_index = sum(drug_class %in% c("er_blockers", "aromatase_inhibitors"))
),
by = c("lopnr", "index_date")
]
```


```{r gr2_estrogen_increase_2hrt}

gr2_ei[
    ,
    gr2_estrogen_increase_2hrt :=
        hrt_dispensations_crc_surgery_6months == TRUE &
            n_hrt_dispensations_before_index >= 2
]

tabyl(gr2_ei, gr2_estrogen_increase_2hrt)
```


+ Postmenopausal women with HRT treatment (G03CA03, G03CA04, G03CC07, G03CX01, G03FA, G03FB) and at least one withdrawal during the period 6 months prior to operation for CRC (a2_opdat). Never used any tamoxifen and fulvestrant (L02BA01, L02BA03) or Aromatase inhibitors (L02BG03, L02BG04 and L02BG06) (from Prescribed Pharmaceutics Register) 
`r colorize("Must the whole group2 not have used AI or ER blockers?")

```{r gr2_estrogen_increase_1hrt}
gr2_ei[
    ,
    gr2_estrogen_increase_1hrt_no_er_ai :=
        hrt_dispensations_crc_surgery_6months == TRUE &
            n_hrt_dispensations_before_index >= 1 &
            n_er_or_ai_dispensations_before_index == 0
]

tabyl(gr2_ei, gr2_estrogen_increase_1hrt_no_er_ai)
```

```{r add gr2 to pop }
gr2_ei[,
    gr2_estrogen_increase := any(gr2_estrogen_increase_2hrt, gr2_estrogen_increase_1hrt_no_er_ai),
    by = c("lopnr", "index_date")
]

pop <- merge(pop,
    gr2_ei[, .(lopnr, index_date, gr2_estrogen_increase)],
    by = c("lopnr", "index_date"), all.x = TRUE
)
pop[is.na(gr2_estrogen_increase), gr2_estrogen_increase := FALSE]
tabyl(pop, gr2_estrogen_increase)
```



#### 3. _Group 3:_ Referens (kvinnor som ej uppfyller kriterier för övriga grupper 1 och 2).   
```{r gr3 women ref}
pop[woman == 1 & gr1_estrogen_decrease != TRUE & gr2_estrogen_increase != TRUE, gr3_ref_woman := TRUE]
pop[is.na(gr3_ref_woman), gr3_ref_woman := FALSE]
tabyl(pop, gr3_ref_woman)
```

#### 4. _Group 4_: Män
```{r gr4_men}
pop[, gr4_men := woman == 0]
tabyl(pop, gr4_men)
```



#### Topikal hrt indicator variables
**topikal_hrt`**
TRUE if used topikal HRT within 2 years prior index_date. Needed for making `exposure_group` variable below

**topikal_hrt_only**
TRUE if only used topikal HRT (no other estrogen increase drugs) within 2 years of `diagdate_scrcr`

```{r create topikal hrt indicators}

# topikal_hrt already created above (chunk create topikal_hrt)
# lmed_clean[topikal_hrt == TRUE]

hrt_indicators <- lmed_clean[drug_class == "hrt_treatment", .(
    hrt_any = any(drug_class == "hrt_treatment"),
    topikal_hrt = any(topikal_hrt),
    # Must have had hrt treatment
    topikal_hrt_only = all(drug_class == "hrt_treatment" & topikal_hrt == TRUE)
),
by = c("lopnr", "diagdate_scrcr")
]


tabyl(hrt_indicators, topikal_hrt)
tabyl(hrt_indicators, topikal_hrt_only)

pop <- left_merge(
    pop,
    hrt_indicators,
    id_vars = c("lopnr", "diagdate_scrcr")
)
```


```{r lform by drug_class}
tabyl(lmed_clean, lform, drug_class)
```



### Make exposure variable
Creating `exposure_group` variable. 

```{r include=FALSE}
overlap_lopnr <- pop[gr1_estrogen_decrease & gr2_estrogen_increase]$lopnr
# Hur ser deras anvandning ut i lakemedelsregistret?
x <- lmed_clean[lopnr %in% overlap_lopnr]
# typ alla har fått topikala hrt medan de egentligen är estrogen-sänkare
```

`r colorize("there are some overlapping in gr1 (estrogen decrease) and gr2 (estrogen increase). 
For women with the topikal_hrt_only flag that are included included in both gr1 and gr2 are defined as
being in the estrogen decrease group (gr1) instead of estrogen increase (gr2)")`

```{r create exposure variable}
pop[, exposure_group := case_when(

    # For the overlapping women (gr1 and gr2). They are estrogen decreasers (gr1)
    # but are also using topikal hrt so they should be kept in gr1 as topikal hrt have low priority.
    # The added step to the algorithm is actually not necessary as the order would already put them in
    # the correct group but it is good for clarity

    gr1_estrogen_decrease == TRUE &
        gr2_estrogen_increase == 2 &
        topikal_hrt_only == TRUE ~ "gr1_estrogen_decrease",
    gr1_estrogen_decrease == TRUE ~ "gr1_estrogen_decrease",
    gr2_estrogen_increase == TRUE ~ "gr2_estrogen_increase",
    gr3_ref_woman == TRUE ~ "gr3_women",
    gr4_men == TRUE ~ "gr4_men",
    TRUE ~ ""
)]

tabyl(pop, exposure_group, gr1_estrogen_decrease)
tabyl(pop, exposure_group, gr2_estrogen_increase)
tabyl(pop, exposure_group, gr3_ref_woman)
tabyl(pop, exposure_group, gr4_men)
```


topikal hrt is by far the most common hrt treatment and many (~60% ish) have only used topikal hrt
```{r compare topikal hrt and exposure group}

tabyl(pop, topikal_hrt, topikal_hrt_only)
tabyl(pop, exposure_group, topikal_hrt)
tabyl(pop, exposure_group, topikal_hrt_only)
```



### Other variables

#### ooforectomy	Indicator for previous ooforectomy surgery
* 1 = YES if hit in “mr_ooforectomies_20210607” 
* 0 = NO 



**Based on the following codes in IPR/OPR:**   
* LAE 10/11 unilateral ooforectomi   
* LAE 20/21 bilat ooforectomi   
* LAF 00/01 unilateral salpingo- ooforectomi   
* LAF 10/11 bilat salpingo- ooforectomi   
* LAF 20/21 unilat transvaginal   
* LAF 30/31 bilat transvaginal   


Distribution of first atgardskod indicating ooforectomy (`indate`) (before `diagdate_scrcr`) found in the population ():

```{r ooforectomy}
# Dataset contains all the hits containing any ooforectomy (removal of the ovaries)
# before index_date (diagdate_scrcr)
if (nrow(ooforectomies[indate > diagdate_scrcr]) > 0) stop("ooforectomy after index_date")

# The dataset contains duplicates but only because the atgardskoder have been identified from
# both in and outpatient register
oof_pop <- ooforectomies[lopnr %in% pop$lopnr]
oof_pop[!duplicated(lopnr)] %>% tabyl(code)
```
`r colorize("Ingen förekomst av LAF 30/31")`

Creating variable `ooforectomy`. Prevalens in the population:
```{r create ooforectomy var}
lopnr_oof <- unique(oof_pop$lopnr)
pop[, ooforectomy := case_when(
    lopnr %in% lopnr_oof ~ TRUE,
    TRUE ~ FALSE
)]

pop %>% tabyl(ooforectomy)
```

#### Kastration
Kodas till kastration (ja/nej) om antingen: 

```{r kastration}

kast_def1_codes <- c(
    "LAE20",
    "LAE21",
    "LAF10",
    "LAF11",
    "LAF30",
    "LAG31"
)

kast_def2_codes <- c(
    "LAE10",
    "LAE11",
    "LAF00",
    "LAF01"
)

# Need to include all kastration code before procedure date if that is needed
# (instead of diagdate_scrcr like today). Then use this
kastration <- bind_rows()
```

**Definition 1**   
One hit before (diagdate_scrcr):
* LAE20/21
* LAF10/11
* LAF30/31
```{r kastration def2}
lopnr_kast_def1 <- unique(oof_pop[code %in% kast_def1_codes]$lopnr)
length(lopnr_kast_def1)
```


**Definition 2**
* LAE10/11 
* LAF00/01
* LAF20/21 
följt av någon ytterligare åtgärdskod under observationstiden före operation (för att fånga unilateral ooforektomi x 2)

`r colorize("Har ej tillgång till patientregister till och med proceduredate.
Enbart upp till diagdate_scrcr för tillfället.
Kan efterföljande vara vilken som helst av oorectomy åtgärdskoderna?")`

```{r kastration def 2}

oof_pop[, min_date_kast2 := min(outdate[code %in% kast_def2_codes]),
    by = "lopnr"
]

oof_pop[, kast_def2 := case_when(
    # TODO am I sure about this definition. ANY code following the kast_def2 codes?
    outdate >= min_date_kast2 ~ TRUE,
    TRUE ~ FALSE
)]

# Get the lopnr for def2
lopnr_kast_def2 <- oof_pop[kast_def2 == TRUE]
length(lopnr_kast_def2)
```

```{r add kastration to population}
lopnr_kast <- unique(c(lopnr_kast_def1, lopnr_kast_def2))

pop[, kastration := case_when(
    lopnr %in% lopnr_kast ~ TRUE,
    TRUE ~ FALSE
)]
```



#### Additional variables from SCRCR


```{r table1 vars}

# From scrcr
scrcr_add_vars <- scrcr_pop[, .(
    lopnr,
    diagdate_scrcr,
    asa_class,
    location,
    col_location,
    ct,
    cn,
    cm,
    pt,
    pt_cat,
    pn,
    pm,
    bmi,
    # bmi_cat, # created below

    neoadj_ct,
    neoadj_ct_o1,
    neoadj_rt,
    neoadj_rt_o1,
    # neoadj_rt_ct_o1 # created below

    a2_lapa,
    a2_rscop,
    # surgery_type, # already in pop, derived from a2_optyp2
    emergency_surgery, # derived from a2_optyp1, TODO not in scrcr_cleaned

    # diverting_stoma
    a2_skydd,
    a2_stomi,
    perop_bleed,
    # hospital_annual_volume a
    surgery_hospital, # A0_opsjhkod,
    # clinic_annual_volume
    surgery_clinic # 0_opklinkod,
)]


pop <- left_merge(
    pop,
    scrcr_add_vars,
    id_vars = c("lopnr", "diagdate_scrcr")
)
```


##### Hospital volume

Estimate the annual hospital volume per hospital for the whole study period then left join it to the population.
```{r include=FALSE}
tabyl(scrcr$surgery_hospital)
tabyl(scrcr$surgery_clinic)
```

```{r study period years}
rng_study_period <- range(scrcr$diagdate_scrcr)
study_period_years <- abs(time_length(rng_study_period[1] - rng_study_period[2], unit = "years"))
study_period_years
```

`r colorize("Are all hospitals/clinics available for the whole study period")`
```{r annual hospital volume}

hospital_volume <- scrcr[, .(volume = .N), by = "surgery_hospital"]
hospital_volume[, annual_hospital_volume := volume / study_period_years]


hospital_volume

pop <- left_merge(
    pop,
    hospital_volume[, .(surgery_hospital, annual_hospital_volume)],
    id_vars  = "surgery_hospital"
)
```


#### Clinic volume

```{r annual clinic volume}
clinic_volume <- scrcr[, .(volume = .N), by = "surgery_clinic"]
clinic_volume[, annual_clinic_volume := volume / study_period_years]

clinic_volume

pop <- left_merge(
    pop,
    clinic_volume[, .(surgery_clinic, annual_clinic_volume)],
    id_vars = "surgery_clinic"
)
```



###### bmi_cat
* <25 
* 25-30 
* \>30 

```{r bmi_cat}

pop[, bmi_cat := case_when(
    bmi < 25 ~ "<25",
    bmi >= 25 & bmi <= 30 ~ "25-30",
    bmi >= 30 ~ ">=30",
    TRUE ~ NA_character_
)]

tabyl(pop, bmi_cat)
```

###### neoadj_rt_ct_o1  

Much more missing for the _o1 variables (these are oncoloy variables with higher validity but mor missing):
```{r tabyl neoadj variables}
pop %>%
    select(contains("neoadj_")) %>%
    lapply(function(x) tabyl(x))
```

```{r neodj overlap}
# Och värdena överlappar inte direkt även om det är bättre för RT
tabyl(pop, neoadj_ct, neoadj_ct_o1)
tabyl(pop, neoadj_rt, neoadj_rt_o1)
```

If information is available for the _o1 (oncology) variables it has priority over the scrcr variables. 

**Create `neoadj_rt_o1_priority` and `neoadj_ct_o1_priority`**

```{r create o1 priority variables}
pop[, `:=`(
    neoadj_rt_o1_priority = case_when(
        !is.na(neoadj_rt_o1) ~ neoadj_rt_o1,
        TRUE ~ neoadj_rt
    ),
    neoadj_ct_o1_priority = case_when(
        !is.na(neoadj_ct_o1) ~ neoadj_ct_o1,
        TRUE ~ neoadj_ct
    )
)]
```

`neoadj_ct_rt_o1_priority = neoadj_ct_o1_priority & neoad_rt_o1_priority`

```{r neoadj rt ct o1}

# Definiera
pop[, neoadj_rt_ct_o1_priority := case_when(
    neoadj_ct_o1_priority & neoadj_rt_o1_priority ~ TRUE,
    TRUE ~ FALSE
)]

tabyl(pop, neoadj_rt_ct_o1_priority)
```


###### diverting_stoma 

a2_skydd OR a2_stomi

```{r diverting stoma}

pop[
    ,
    diverting_stoma := truethy(a2_skydd) | a2_stomi
]
tabyl(pop, diverting_stoma)
```

###### Tumour location
1 = "colon"
2 = "rektum"

```{r tumour location}
pop[, tumour_location := define_tumour_location(location = location)]
```

###### Colon location
```{r colon location}
pop[, colon_location := define_colon_location(col_location = col_location)]
```


#### Additional variabler from PDR 



#### Additional variabler from Death register 
##### Dead 
dead (from cdr) 
```{r dead from cdr}
pop[, dead := case_when(
    !is.na(deathdate) ~ TRUE,
    TRUE ~ FALSE
)]
tabyl(pop, dead)
```

##### 90-day postop mort
dead90 (from cdr + scrcr) 

```{r dead90 tabyl}
tabyl(pop, dead90)
```

#### Additional variables from other sources

##### CCI 
cci_weighted (from cci)
```{r cci_weighted}
# TODO lots of missing (50% not even in the dataset)
pop <- left_merge(
    pop,
    cci[lopnr %in% pop_lopnr, .(lopnr, diagdate_scrcr, cci_weighted)],
    id_vars = c("lopnr", "diagdate_scrcr")
)

# All that are not in the dataset does not even have a visit in the patient register. Hence the cci=0
pop[is.na(cci_weighted), cci_weighted := 0]

tabyl(pop, cci_weighted)
```


#### Additional variables from LISA
##### Income 
dispink04_YYYY (from LISA, take most recent *before/on diagdate_scrcr/index_date

```{r income}

dispink <- lisa[lopnr %in% pop_lopnr] %>%
    select(lopnr, contains("dispink04")) %>%
    melt(
        id.vars = "lopnr",
        value.name = "income"
    ) %>%
    arrange(lopnr, variable) %>%
    # Remove the _fn1, _fn2 variables
    filter(!grepl("_fn", variable)) %>%
    mutate(income_year = as.numeric(str_extract(variable, "[0-9]{4}$")))


dispink <- merge(
    dispink,
    pop[, .(lopnr, index_date)],
    by = "lopnr", all.x = TRUE
)

# make sure all have an income before index date (that is not missing)
dispink[, index_year := year(index_date)]
dispink[, income_before_index := income_year <= index_year & !is.na(income)]
if (nrow(dispink[, .(n_before = sum(income_before_index)), by = "lopnr"][n_before == 0])) {
    warning("Some without income before index date")
}

dispink_bf_index <- dispink[index_year >= income_year & !is.na(income)]
dispink_bf_index[, most_recent_income_year := max(income_year), by = "lopnr"]
dispink_most_recent <- dispink_bf_index[most_recent_income_year == income_year]
# All have income for the index year

# Add to population
pop <- left_merge(
    pop,
    dispink_most_recent[, .(lopnr, income_year, income)]
)
# add aggregate
pop[, .(
    mean_income = mean(income, na.rm = TRUE),
    median_income = median(income, na.rm = TRUE),
    missing_income = scales::percent(mean(is.na(income)))
)]
```


##### Education
sun2000_nivaold (from LISA, take most recent (before/on index_year))

```{r education}

edu <- lisa %>%
    select(lopnr, contains("sun2000niva_old")) %>%
    melt(
        id.vars = "lopnr",
        value.name = "education",
        variable.name = "sun2000"
    ) %>%
    mutate(
        year_str = str_remove(sun2000, "^sun2000niva_old"),
        year_str2 = str_remove(year_str, "_fn[1-3]{1}"),
        edu_year = as.numeric(year_str2)
    ) %>%
    filter(!grepl("_fn[1-3]{1}", sun2000)) %>%
    arrange(lopnr, edu_year)

edu <- merge(
    edu,
    pop[, .(lopnr, index_date)],
    by = "lopnr", all.x = TRUE
)

# process education (education before index date, a valid education value)
edu[, index_year := year(index_date)]
edu[, edu_before_index := edu_year <= index_year & !is.na(education)]
if (nrow(edu[, n_edu_bf_index := sum(edu_before_index), by = "lopnr"][n_edu_bf_index == 0])) {
    warning("Indivividuals without educational level before index year")
}

edu_before_index <- edu[edu_before_index == TRUE]
edu_before_index[, most_recent_edu_year := max(edu_year), by = "lopnr"]
edu_most_recent <- edu_before_index[most_recent_edu_year == edu_year]
if (any(duplicated(edu_most_recent$lopnr))) {
    warning("duplicates but why! Handled by aggregating and using the
    maximum education")
    edu_most_recent <- edu_most_recent[, .(
        education = max(education),
        edu_year = max(edu_year),
        by = "lopnr"
    )]
}

print("Ändrar * till NA. enligt
https://www.scb.se/contentassets/f0bc88c852364b6ea5c1654a0cc90234/dokumentation-av-lisa.pdf")

edu_most_recent[education == "*", education := NA]
```

```{r edu cat}
# 1) Förgymnasial utbildning kortare än 9 år 1
# 2) Förgymnasial utbildning 9 år (motsvarande) 2
# 3) Gymnasial utbildning högst 2-årig 31, 32
# 4) Gymnasial utbildning 3 år 33
# 5) Eftergymnasial utbildning kortare än 3 år 41, 52
# 6) Eftergymnasial utbildning 3 år eller längre 53, 54, 55
# 7) Forskarutbildning 6
# * Uppgift saknas 9

edu_most_recent[, education := as.numeric(education)]

edu_most_recent[
    ,
    education_cat := case_when(
        education %in% 1 ~ "<9",
        education %in% 2:4 ~ "9-12",
        education %in% 5:7 ~ ">12",
        TRUE ~ ""
    )
]
tabyl(edu_most_recent, education_cat, education)
```


```{r add educationt to pop}

# Adding to population
pop <- left_merge(
    pop,
    edu_most_recent[, .(lopnr, education, education_cat, edu_year)],
    id_vars = "lopnr"
)
tabyl(pop, education)
```

###### Previous BC (yes/no)? : `bc_index`

```{r previous bc}
# add index date to bc
bc_clean <- merge(
    bc_clean,
    pop[, .(lopnr, index_date)],
    by = "lopnr"
)
# All bc occurr before diagdate_bc

lopnr_bc <- bc_clean[diagdate_bc <= index_date]$lopnr %>% unique()

pop[, bc_index := case_when(
    lopnr %in% lopnr_bc ~ TRUE,
    TRUE ~ FALSE
)]
tabyl(pop, bc_index)
```

###### diagnois year?  
already in analysesdata
```{r diagnosis year include}
tabyl(pop, diagyear_scrcr)
```

##### Previous ooforectomy 
(yes/no)
```{r}
tabyl(pop, ooforectomy)
```






```{r make all binary variables truethy}
pop <- pop %>%
    mutate_if(is.logical, function(x) {
        x <- as.numeric(x)
        return(x)
    })
```


# Write analysesdata to disk 
derived folder
```{r save population}
write_file_to_derived_folder_project(pop, project_name = params$project_name, csv_name = "mr1_analyses_data.csv")
```